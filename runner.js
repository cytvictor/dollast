// Generated by LiveScript 1.3.1
(function(){
  var async, util, childProcess, config, fs, tmp, langSuffix, compile, run, judge, out$ = typeof exports != 'undefined' && exports || this;
  async = require('async');
  util = require('util');
  childProcess = require('child_process');
  config = require('./config');
  fs = require('fs');
  tmp = require('tmp');
  langSuffix = {
    'C': 'c',
    'C++': 'cpp',
    'Java': 'java'
  };
  compile = function*(lang, code, cb){
    var path, srcFile, compileCmd, output, err;
    path = yield tmp.file({
      postfix: langSuffix[lang]
    });
    console.log(path + "");
    srcFile = fs.createWriteStream(path);
    yield srcFile.write(code);
    compileCmd = format(path.apply(this, arguments));
    output = yield childProcess.exec(config.compileCmd[lang]);
    err = findErr(output);
  };
  run = function*(lang, code, dataAtom, exe){
    var child;
    child = childProcess.spawn('./sandbox');
    child.on('data', function(chunk){
      return console.log("on data " + chunk);
    });
    child.on('exit', function(code, signal){
      console.log("on exit: " + code + " " + signal);
      return cb({
        time: Math.random() * 2,
        space: Math.random() * 128,
        result: Math.random()
      });
    });
    child.stdin.write(lang + " " + util.inspect(dataAtom) + " " + exe);
  };
  out$.judge = judge = function*(lang, code, probConfig){
    var tasks;
    tasks = map(function(){
      return function(cb){
        return run(lang, code, it, cb);
      };
    })(
    probConfig.dataset);
    return new Promise(function*(resolve, reject){
      var result;
      result = yield async.parallelLimit(tasks, config.concurrency);
    });
  };
}).call(this);
