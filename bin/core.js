// Generated by LiveScript 1.3.1
var async, util, fs, childProcess, tmp, bluebird, co, debug, path, coLimiter, _, config, log, asyc, compile, flattenDir, upload, genDataPairs, testlibExitcodes, judgeResult, limit, runAtom, calcProbScore, judge, out$ = typeof exports != 'undefined' && exports || this, slice$ = [].slice;
async = require('async');
util = require('util');
fs = require('mz/fs');
childProcess = require('mz/child_process');
tmp = require('tmp');
bluebird = require('bluebird');
co = require('co');
debug = require('debug');
path = require('path');
coLimiter = require('co-limiter');
_ = require('prelude-ls');
config = require('./config');
log = debug('core');
asyc = bluebird.promisifyAll(async);
out$.compile = compile = co.wrap(function*(tmpDir, lang, code){
  var srcPath, exePath, srcFile, compileCmd;
  srcPath = path.join(tmpDir, "/main" + config.langSuffix[lang]);
  exePath = path.join(tmpDir, "/main");
  srcFile = fs.createWriteStream(srcPath);
  yield fs.writeFile(srcPath, code);
  compileCmd = config.compileFmt[lang](srcPath, exePath);
  log("compile-cmd " + compileCmd);
  yield childProcess.exec(compileCmd);
  return exePath;
});
flattenDir = function*(baseDir){
  var walk;
  walk = function*(dir){
    var files, i$, len$, file;
    files = fs.readdirSync(dir);
    for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
      file = files[i$];
      if (fs.statSync(file).isDirectory()) {
        walk(path.join(dir, file));
        fs.rmdir(dir);
      } else if (dir !== baseDir) {
        fs.renameSync;
      }
    }
  };
  walk(baseDir);
};
out$.upload = upload = co.wrap(function*(pid, part){
  var extName, zipFile, dataDir, ref$, stdout, stderr, err, ret;
  extName = path.extname(part.filename);
  zipFile = tmp.fileSync({
    postfix: extName
  });
  log("upload " + part.filename + " -> " + zipFile.name);
  try {
    part.pipe(fs.createWriteStream(zipFile.name));
    dataDir = path.join(config.dataDir, "/" + pid);
    ref$ = yield childProcess.exec("7z e " + zipFile.name + " -o" + dataDir + " -y"), stdout = ref$[0], stderr = ref$[1];
    log("output: " + stdout + " " + stderr);
    flattenDir(dataDir);
  } catch (e$) {
    err = e$;
    ret = {
      status: "decompressing error"
    };
  } finally {
    zipFile.removeCallback();
    ret = {
      status: "OK"
    };
  }
  log("unzip status: " + util.inspect(ret));
  return ret;
});
out$.genDataPairs = genDataPairs = co.wrap(function*(pid){
  var dataDir, files, pairs, i$, len$, inf, infPath, ouf;
  dataDir = path.join(config.dataDir, "/" + pid + "/");
  files = fs.readdirSync(dataDir);
  log("files: " + files);
  pairs = [];
  for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
    inf = files[i$];
    infPath = path.join(dataDir, inf);
    if (".in" === path.extname(inf)) {
      ouf = _.take(inf.length - 2, inf);
      ouf = ouf + "out";
      if (yield fs.exists(path.join(dataDir, ouf))) {
        log("find a pair: " + inf + " => " + ouf);
        pairs.push({
          input: inf,
          output: ouf
        });
      }
    }
  }
  return pairs;
});
testlibExitcodes = {
  0: 'ok',
  1: 'wa',
  2: 'pe',
  3: 'fail',
  6: 'unexpected'
};
judgeResult = co.wrap(function*(pid, inFile, outFile, ansFile, cfg){
  var judger, ref$, stdout, stderr, e, messages, status, score, message;
  judger = (function(){
    switch (cfg.judger) {
    case 'string':
      return path.join(config.judgerDir, "/string");
    case 'real':
      return path.join(config.judgerDir, "/real");
    case 'strict':
      return path.join(config.judgerDir, "/strict");
    case 'custom':
      return path.join(config.dataDir, "/" + pid + "/", "/judge");
    default:
      throw Error('unimplemented');
    }
  }());
  try {
    ref$ = yield childProcess.exec(judger + " " + inFile + " " + outFile + " " + ansFile), stdout = ref$[0], stderr = ref$[1];
  } catch (e$) {
    e = e$;
    messages = _.unlines(_.drop(1, _.lines(e.message)));
    return {
      status: testlibExitcodes[e.code],
      score: 0,
      message: messages.trim()
    };
  }
  ref$ = stderr.trim().split(' '), status = ref$[0], score = ref$[1], message = slice$.call(ref$, 2);
  log("judger output: " + stdout + " / " + status + " / " + score + " / " + message);
  message = _.unwords(message);
  return {
    status: status,
    score: parseFloat(score),
    message: message
  };
});
limit = coLimiter(config.concurrency);
runAtom = function*(pid, lang, exePath, data, cfg){
  var tmpFile, ouf, inf, ans, execCmd, ref$, procOut, procErr, exeRes, judgeRes;
  log("running atom...");
  tmpFile = tmp.fileSync();
  ouf = tmpFile.name;
  inf = path.join(config.dataDir, "/" + pid + "/", data.input);
  ans = path.join(config.dataDir, "/" + pid + "/", data.output);
  log("inf " + inf + " ans " + ans);
  execCmd = "\"" + config.sandboxer + "\" \"" + exePath + "\" " + cfg.timeLmt + " " + cfg.spaceLmt + " " + cfg.stkLmt + " " + cfg.outLmt + " \"" + inf + "\" \"" + ouf + "\"";
  ref$ = yield childProcess.exec(execCmd, {
    cwd: path.dirname(config.sandboxer)
  }), procOut = ref$[0], procErr = ref$[1];
  log("sandboxer result: " + procErr);
  exeRes = JSON.parse(procErr);
  if (exeRes.status !== 'OK') {
    tmpFile.removeCallback();
    return exeRes.input = data.input, exeRes;
  }
  judgeRes = yield judgeResult(pid, inf, ouf, ans, cfg);
  tmpFile.removeCallback();
  return ref$ = import$(exeRes, judgeRes), ref$.input = data.input, ref$;
};
calcProbScore = function(results){
  var ret, ref$, sum, ws, i$, len$, data, result;
  ret = {
    maxTime: 0,
    maxSpace: 0
  };
  ref$ = [0, 0], sum = ref$[0], ws = ref$[1];
  for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
    ref$ = results[i$], data = ref$[0], result = ref$[1];
    if (result.time) {
      ret.maxTime >= (ref$ = result.time) || (ret.maxTime = ref$);
    }
    if (result.space) {
      ret.maxSpace >= (ref$ = result.space) || (ret.maxSpace = ref$);
    }
    sum += data.weight * result.score;
    ws += data.weight;
  }
  return ret.score = sum / ws, ret;
};
out$.judge = judge = co.wrap(function*(lang, code, probConfig, doc){
  var tmpDir, config, pid, exePath, dataset, ref$, results, i$, len$, data, res, err, ret;
  log("Start judging: lang: " + lang);
  tmpDir = tmp.dirSync({
    unsafeCleanup: true
  });
  config = probConfig.toObject();
  pid = doc.prob._id;
  try {
    exePath = yield compile(tmpDir.name, lang, code);
    dataset = (ref$ = config.dataset, delete config.dataset, ref$);
    results = [];
    for (i$ = 0, len$ = dataset.length; i$ < len$; ++i$) {
      data = dataset[i$];
      res = yield limit(runAtom(pid, lang, exePath, data, config));
      results.push(res);
    }
    log("starting modifying doc");
    doc.results = results;
    import$(doc, calcProbScore(_.zip(dataset, results)));
    yield doc.save();
  } catch (e$) {
    err = e$;
    log(err);
    ret = err;
  } finally {
    tmpDir.removeCallback();
    ret = {
      status: "OK"
    };
  }
  return ret;
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}