// Generated by LiveScript 1.3.1
(function(){
  var mongoose, moment, debug, co, _, conn, db, log, schema, lockProb, unlockProb, model, count, funcNextCount, nextCount, modify, show, board, list, remove, publish, out$ = typeof exports != 'undefined' && exports || this, this$ = this;
  mongoose = require('mongoose');
  moment = require('moment');
  debug = require('debug');
  co = require('co');
  _ = require('prelude-ls');
  conn = require('./conn');
  db = require('../db');
  log = debug("dollast:rnd-model");
  schema = new mongoose.Schema({
    _id: Number,
    author: {
      type: String,
      ref: 'user'
    },
    title: String,
    begTime: Date,
    endTime: Date,
    published: Boolean,
    probs: [{
      type: Number,
      ref: 'problem'
    }]
  });
  schema.methods.isStarted = function(){
    return moment().isAfter(this.begTime);
  };
  schema.methods.isEnded = function(){
    return moment().isAfter(this.endTime);
  };
  lockProb = co.wrap(function*(rid, state, probs){
    var pid;
    log("locking", probs);
    yield (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = probs).length; i$ < len$; ++i$) {
        pid = ref$[i$];
        results$.push(db.prob.model.findByIdAndUpdate(pid, {
          $set: {
            "config.round": rid
          }
        }).exec());
      }
      return results$;
    }());
  });
  unlockProb = co.wrap(function*(rid, state, probs){
    var pid;
    log("unlocking", probs);
    yield (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = probs).length; i$ < len$; ++i$) {
        pid = ref$[i$];
        results$.push(db.prob.model.findByIdAndUpdate(pid, {
          $unset: {
            "config.round": rid
          }
        }).exec());
      }
      return results$;
    }());
  });
  model = conn.conn.model('round', schema);
  count = 0;
  funcNextCount = conn.makeNextCount(model, count);
  out$.nextCount = nextCount = function*(){
    this.acquirePrivilege('rnd-all');
    return yield funcNextCount();
  };
  out$.modify = modify = function*(rid, rnd){
    var that, doc, oldProbs, newProbs;
    if (rnd._id) {
      delete rnd._id;
    }
    if (rid === 0) {
      rid = yield nextCount.bind(this$)();
      rnd._id = rid;
      log({
        rid: rid
      });
    }
    this$.acquirePrivilege('rnd-all');
    if (that = rnd.begTime) {
      rnd.begTime = new Date(that);
    }
    if (that = rnd.endTime) {
      rnd.endTime = new Date(that);
    }
    doc = yield model.findById(rid).exec();
    if (!doc) {
      doc = new model;
    }
    if (rnd.probs) {
      oldProbs = doc.probs || [];
      newProbs = rnd.probs;
      log(oldProbs, newProbs);
      yield unlockProb(rid, false, _.difference(oldProbs, newProbs));
      yield lockProb(rid, true, _.difference(newProbs, oldProbs));
    }
    import$(doc, rnd);
    log(doc);
    yield doc.save();
    return true;
  };
  out$.show = show = function*(rid, opts){
    var rnd;
    opts == null && (opts = {});
    opts.mode || (opts.mode = "view");
    if (opts.mode === "total") {
      this$.acquirePrivilege('rnd-all');
    }
    rnd = yield model.findById(rid, '-__v').populate('probs', '_id outlook.title').lean().exec();
    if (opts.mode === "view" && moment().isBefore(rnd.begTime)) {
      rnd.probs = [];
      rnd.started = false;
    } else {
      rnd.started = true;
    }
    return rnd;
  };
  out$.board = board = function*(rid, opts){
    var rnd, query, results;
    opts == null && (opts = {});
    rnd = yield model.findById(rid, 'published').exec();
    if (!(rnd != null && rnd.published)) {
      this.acquirePrivilege('rnd-all');
    }
    query = db.sol.model.aggregate({
      $match: {
        round: rid
      }
    }, {
      $sort: {
        prob: 1,
        user: 1,
        _id: -1
      }
    }, {
      $group: {
        _id: {
          prob: '$prob',
          user: '$user'
        },
        score: {
          $first: '$final.score'
        },
        sid: {
          $first: '$_id'
        }
      }
    });
    results = yield query.exec();
    return results;
  };
  out$.list = list = function*(){
    return yield model.find({}, 'title begTime endTime').lean().exec();
  };
  out$.remove = remove = function*(rid){
    this$.acquirePrivilege('rnd-all');
    return yield model.findByIdAndRemove(rid).lean().exec();
  };
  out$.publish = publish = function*(rid){
    var doc;
    this.acquirePrivilege('rnd-all');
    doc = yield model.findById(rid).exec();
    if (!doc) {
      throw new Error("no such round");
    }
    if (moment().isBefore(doc.endTime)) {
      throw new Error("round is running");
    }
    yield unlockProb(rid, false, doc.probs);
    doc.published = true;
    yield doc.save();
    return {
      status: {
        type: "ok",
        msg: "published all problems"
      }
    };
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
