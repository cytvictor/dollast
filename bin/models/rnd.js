// Generated by LiveScript 1.4.0
(function(){
  var mongoose, moment, debug, co, _, conn, ref$, permitSchema, canAccess, db, log, schema, lockProb, unlockProb, model, count, funcNextCount, nextCount, modify, show, board, list, remove, publish, getUserOwnedRounds, out$ = typeof exports != 'undefined' && exports || this, this$ = this;
  mongoose = require('mongoose');
  moment = require('moment');
  debug = require('debug');
  co = require('co');
  _ = require('prelude-ls');
  conn = require('./conn');
  ref$ = require('./permit'), permitSchema = ref$.schema, canAccess = ref$.canAccess;
  db = require('../db');
  log = debug("dollast:rnd-model");
  schema = new mongoose.Schema({
    _id: Number,
    permit: permitSchema,
    title: String,
    begTime: Date,
    endTime: Date,
    published: Boolean,
    probs: [{
      type: Number,
      ref: 'problem'
    }]
  });
  schema.methods.isStarted = function(){
    return moment().isAfter(this.begTime);
  };
  schema.methods.isEnded = function(){
    return moment().isAfter(this.endTime);
  };
  lockProb = co.wrap(function*(rid, state, probs){
    var pid;
    log("locking", probs);
    return (yield (yield* (function*(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = probs).length; i$ < len$; ++i$) {
        pid = ref$[i$];
        results$.push(db.prob.model.findByIdAndUpdate(pid, {
          $set: {
            "config.round": rid
          }
        }).exec());
      }
      return results$;
    }())));
  });
  unlockProb = co.wrap(function*(rid, state, probs){
    var pid;
    log("unlocking", probs);
    return (yield (yield* (function*(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = probs).length; i$ < len$; ++i$) {
        pid = ref$[i$];
        results$.push(db.prob.model.findByIdAndUpdate(pid, {
          $unset: {
            "config.round": rid
          }
        }).exec());
      }
      return results$;
    }())));
  });
  model = conn.conn.model('round', schema);
  count = 0;
  funcNextCount = conn.makeNextCount(model, count);
  out$.nextCount = nextCount = function*(){
    this.acquirePrivilege('rnd-all');
    return (yield funcNextCount());
  };
  out$.modify = modify = function*(rid, rnd){
    var that, doc, oldProbs, newProbs;
    if (rnd._id) {
      delete rnd._id;
    }
    if (rid === 0) {
      rid = (yield nextCount.bind(this$)());
      rnd._id = rid;
      log({
        rid: rid
      });
    } else {
      this$.ensureAccess(model, rid, 'w');
    }
    if (that = rnd.begTime) {
      rnd.begTime = new Date(that);
    }
    if (that = rnd.endTime) {
      rnd.endTime = new Date(that);
    }
    doc = (yield model.findById(rid).exec());
    if (!doc) {
      doc = new model;
    }
    if (rnd.probs) {
      oldProbs = doc.probs || [];
      newProbs = rnd.probs;
      log(oldProbs, newProbs);
      (yield unlockProb(rid, false, _.difference(oldProbs, newProbs)));
      (yield lockProb(rid, true, _.difference(newProbs, oldProbs)));
    }
    import$(doc, rnd);
    log(doc);
    (yield doc.save());
    return true;
  };
  out$.show = show = function*(rid, opts){
    var rnd;
    opts == null && (opts = {});
    opts.mode || (opts.mode = "view");
    if (opts.mode === "total") {
      this$.ensureAccess(model, rid, 'r');
    }
    rnd = (yield model.findById(rid, '-__v').populate('probs', '_id outlook.title').lean().exec());
    if (opts.mode === "view" && moment().isBefore(rnd.begTime)) {
      rnd.probs = [];
      rnd.started = false;
    } else {
      rnd.started = true;
    }
    return rnd;
  };
  out$.board = board = function*(rid, opts){
    opts == null && (opts = {});
    this.ensureAccess(model, rid, 'r');
    return (yield db.sol.getSolutionsInARound(rid));
  };
  out$.list = list = function*(){
    return (yield model.find({}, 'title begTime endTime').lean().exec());
  };
  out$.remove = remove = function*(rid){
    this$.ensureAccess(model, rid, 'w');
    return (yield model.findByIdAndRemove(rid).lean().exec());
  };
  out$.publish = publish = function*(rid){
    var doc;
    this.ensureAccess(model, rid, 'w');
    doc = (yield model.findById(rid).exec());
    if (!doc) {
      throw new Error("no such round");
    }
    if (moment().isBefore(doc.endTime)) {
      throw new Error("round is running");
    }
    (yield unlockProb(rid, false, doc.probs));
    doc.published = true;
    (yield doc.save());
    return {
      status: {
        type: "ok",
        msg: "published all problems"
      }
    };
  };
  out$.getUserOwnedRounds = getUserOwnedRounds = function*(uid){
    return (yield model.find({
      'permit.owner': uid
    }, '_id title begTime endTime').exec());
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
