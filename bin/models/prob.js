// Generated by LiveScript 1.3.1
(function(){
  var mongoose, debug, map, sanitizeHtml, conn, permitSchema, genDataPairs, probListOpts, db, log, schema, model, count, show, stat, list, updData, listDataset, funcNextCount, nextCount, modify, out$ = typeof exports != 'undefined' && exports || this;
  mongoose = require('mongoose');
  debug = require('debug');
  map = require('prelude-ls').map;
  sanitizeHtml = require('sanitize-html');
  conn = require('./conn');
  permitSchema = require('./permit').schema;
  genDataPairs = require('../core').genDataPairs;
  probListOpts = require('../config').probListOpts;
  db = require('../db');
  log = debug("dollast:prob");
  schema = new mongoose.Schema({
    _id: Number,
    outlook: {
      desc: String,
      title: String,
      inFmt: String,
      outFmt: String,
      sampleIn: String,
      sampleOut: String
    },
    config: {
      round: {
        type: Number,
        ref: "round"
      },
      timeLmt: Number,
      spaceLmt: Number,
      stkLmt: Number,
      outLmt: Number,
      regexp: String,
      judger: String,
      dataset: [{
        input: String,
        output: String,
        weight: Number
      }]
    },
    stat: {},
    permit: permitSchema
  });
  out$.model = model = conn.conn.model('problem', schema);
  count = 0;
  out$.show = show = function*(pid, opts){
    var fields, ref$, prob, ref1$;
    opts == null && (opts = {});
    opts.mode || (opts.mode = "view");
    opts.mode = 'total';
    fields = (function(){
      switch (opts.mode) {
      case "view":
        return "outlook config.timeLmt config.spaceLmt config.round";
      case "total":
        return undefined;
      case "brief":
        return "outlook.title config.round";
      default:
        throw Error('unimplemented');
      }
    }());
    if ((ref$ = opts.mode) === "total" || ref$ === "view") {
      this.ensureAccess(model, pid, 'r');
    }
    prob = yield model.findById(pid, fields).populate("config.round", "begTime").exec();
    if (!prob) {
      throw new Error("no such problem");
    }
    if ((prob != null ? (ref$ = prob.config) != null ? ref$.round : void 8 : void 8) != null) {
      prob = prob.toObject();
      (ref1$ = prob.config).round = ref1$.round._id;
    } else {
      prob = prob.toObject();
    }
    return prob;
  };
  out$.stat = stat = function*(pid, opts){
    var prob, query, stat;
    opts == null && (opts = {});
    prob = yield model.findById(pid, 'config.round outlook.title').populate('config.round', 'published').lean().exec();
    if (!prob) {
      throw new Error("no such problem");
    }
    this.ensureAccess(model, pid, 'r');
    query = db.sol.model.aggregate({
      $match: {
        prob: pid
      }
    }, {
      $sort: {
        user: 1,
        "final.score": -1
      }
    }, {
      $project: {
        lang: true,
        final: true,
        round: true,
        user: true
      }
    }, {
      $group: {
        _id: {
          user: "$user"
        },
        doc: {
          $first: "$$CURRENT"
        },
        submits: {
          $sum: 1
        }
      }
    });
    stat = yield query.exec();
    delete prob.config;
    return {
      sols: stat,
      prob: prob
    };
  };
  out$.list = list = function*(opts){
    opts = import$(clone$(probListOpts), opts);
    return yield model.find(null, 'outlook.title').skip(opts.skip).limit(opts.limit).exec();
  };
  out$.updData = updData = function*(pid){
    var prob, pairs;
    this.acquirePrivilege('prob-all');
    prob = yield model.findById(pid, 'config.dataset').exec();
    pairs = yield genDataPairs(pid);
    prob.config.dataset = map((function(it){
      return it.weight = 1, it;
    }), pairs);
    yield prob.save();
    return pairs;
  };
  out$.listDataset = listDataset = function*(pid){
    var prob;
    this.acquirePrivilege('prob-all');
    prob = yield model.findById(pid, "config.dataset").lean().exec();
    return prob.config.dataset;
  };
  funcNextCount = conn.makeNextCount(model, count);
  nextCount = function*(){
    log("next-count");
    return yield funcNextCount();
  };
  out$.modify = modify = function*(pid, prob){
    var ref$;
    this.ensureAccess(model, pid, 'w');
    if (prob._id) {
      delete prob._id;
    }
    if (pid === 0) {
      pid = yield nextCount.bind(this)();
      log({
        pid: pid
      });
    }
    if (prob.outlook.desc) {
      (ref$ = prob.outlook).desc = sanitizeHtml(ref$.desc);
    }
    return yield model.update({
      _id: pid
    }, {
      $set: prob
    }, {
      upsert: true,
      overwrite: true
    }).exec();
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);
