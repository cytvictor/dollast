// Generated by LiveScript 1.3.1
/*
  A `problem` may belong to some `round`.
  When we create a `round`, we must take care of these problems.
*/
(function(){
  var mongoose, util, debug, _, sanitizeHtml, conn, core, config, db, log, schema, model, count, show, stat, list, updData, listDataset, funcNextCount, nextCount, modify, out$ = typeof exports != 'undefined' && exports || this;
  mongoose = require('mongoose');
  util = require('util');
  debug = require('debug');
  _ = require('prelude-ls');
  sanitizeHtml = require('sanitize-html');
  conn = require('./conn');
  core = require('../core');
  config = require('../config');
  db = require('../db');
  log = debug("dollast:prob");
  schema = new mongoose.Schema({
    _id: Number,
    outlook: {
      desc: String,
      title: String,
      inFmt: String,
      outFmt: String,
      sampleIn: String,
      sampleOut: String
    },
    config: {
      author: {
        type: String,
        ref: 'user'
      },
      round: {
        type: Number,
        ref: "round"
      },
      timeLmt: Number,
      spaceLmt: Number,
      stkLmt: Number,
      outLmt: Number,
      regexp: String,
      judger: String,
      dataset: [{
        input: String,
        output: String,
        weight: Number
      }]
    },
    stat: {}
  });
  out$.model = model = conn.conn.model('problem', schema);
  count = 0;
  out$.show = show = function*(pid, opts){
    var fields, prob, that, ref$, ref1$;
    opts == null && (opts = {});
    opts.mode || (opts.mode = "view");
    fields = (function(){
      switch (opts.mode) {
      case "view":
        return "outlook config.timeLmt config.spaceLmt config.round";
      case "total":
        return undefined;
      case "brief":
        return "outlook.title config.round";
      default:
        throw Error('unimplemented');
      }
    }());
    if (opts.mode === "total") {
      this.acquirePrivilege('prob-all');
    }
    prob = yield model.findById(pid, fields).populate("config.round", "begTime").exec();
    if (!prob) {
      throw new Error("no such problem");
    }
    if ((that = prob != null ? (ref$ = prob.config) != null ? ref$.round : void 8 : void 8) != null) {
      if (!that.isStarted()) {
        this.acquirePrivilege('prob-all');
      }
      prob = prob.toObject();
      (ref1$ = prob.config).round = ref1$.round._id;
    } else {
      prob = prob.toObject();
    }
    return prob;
  };
  out$.stat = stat = function*(pid, opts){
    var prob, that, ref$, query, stat;
    opts == null && (opts = {});
    prob = yield model.findById(pid, 'config.round').populate('config.round', 'published').exec();
    if (!prob) {
      throw new Error("no such problem");
    }
    if ((that = (ref$ = prob.config) != null ? ref$.round : void 8) != null) {
      if (!that.published) {
        this.acquirePrivilege('rnd-all');
      }
    }
    query = db.sol.model.aggregate({
      $match: {
        prob: pid
      }
    }, {
      $sort: {
        user: 1,
        "final.score": -1
      }
    }, {
      $project: {
        lang: true,
        final: true,
        round: true,
        user: true
      }
    }, {
      $group: {
        _id: {
          user: "$user"
        },
        doc: {
          $first: "$$CURRENT"
        },
        submits: {
          $sum: 1
        }
      }
    });
    stat = yield query.exec();
    return {
      sols: stat
    };
  };
  out$.list = list = function*(opts){
    opts = import$(clone$(config.probListOpts), opts);
    return yield model.find(null, 'outlook.title').skip(opts.skip).limit(opts.limit).exec();
  };
  out$.updData = updData = function*(pid){
    var prob, pairs;
    this.acquirePrivilege('prob-all');
    prob = yield model.findById(pid, 'config.dataset').exec();
    pairs = yield core.genDataPairs(pid);
    prob.config.dataset = _.map((function(it){
      return it.weight = 1, it;
    }), pairs);
    yield prob.save();
    return pairs;
  };
  out$.listDataset = listDataset = function*(pid){
    var prob;
    this.acquirePrivilege('prob-all');
    prob = yield model.findById(pid, "config.dataset").lean().exec();
    return prob.config.dataset;
  };
  funcNextCount = conn.makeNextCount(model, count);
  out$.nextCount = nextCount = function*(){
    log("next-count");
    this.acquirePrivilege('prob-all');
    return yield funcNextCount();
  };
  out$.modify = modify = function*(pid, prob){
    var ref$;
    this.acquirePrivilege('prob-all');
    if (prob._id) {
      delete prob._id;
    }
    if (pid === 0) {
      pid = yield nextCount.bind(this)();
      log({
        pid: pid
      });
    }
    if (prob.outlook.desc) {
      (ref$ = prob.outlook).desc = sanitizeHtml(ref$.desc);
    }
    return yield model.update({
      _id: pid
    }, {
      $set: prob
    }, {
      upsert: true,
      overwrite: true
    }).exec();
  };
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);
