// Generated by LiveScript 1.3.1
var mongoose, util, debug, _, conn, core, config, db, log, schema, model, count, out$ = typeof exports != 'undefined' && exports || this;
mongoose = require('mongoose');
util = require('util');
debug = require('debug');
_ = require('prelude-ls');
conn = require('./conn');
core = require('../core');
config = require('../config');
db = require('../db');
log = debug("dollast:prob");
schema = new mongoose.Schema({
  _id: Number,
  outlook: {
    desc: String,
    title: String,
    inFmt: String,
    outFmt: String,
    sampleIn: String,
    sampleOut: String
  },
  config: {
    round: {
      type: Number,
      ref: "round"
    },
    timeLmt: Number,
    spaceLmt: Number,
    stkLmt: Number,
    outLmt: Number,
    regexp: String,
    judger: String,
    dataset: [{
      input: String,
      output: String,
      weight: Number
    }]
  },
  stat: {}
});
out$.model = model = conn.conn.model('problem', schema);
count = 0;
import$(out$, {
  show: function*(pid, opts){
    var fields, prob, that, ref$, ref1$;
    opts == null && (opts = {});
    opts.mode || (opts.mode = "view");
    fields = (function(){
      switch (opts.mode) {
      case "view":
        return "outlook config.timeLmt config.spaceLmt config.round";
      case "total":
        return undefined;
      case "brief":
        return "outlook.title config.round";
      default:
        throw Error('unimplemented');
      }
    }());
    if (opts.mode === "total") {
      this.acquirePrivilege('prob-all');
    }
    prob = yield model.findById(pid, fields).populate("config.round", "begTime").exec();
    if ((that = prob != null ? (ref$ = prob.config) != null ? ref$.round : void 8 : void 8) != null) {
      if (!that.isStarted()) {
        this.acquirePrivilege('prob-all');
      }
      prob = prob.toObject();
      (ref1$ = prob.config).round = ref1$.round._id;
    } else if (prob) {
      prob = prob.toObject();
    }
    return prob;
  },
  stat: function*(pid, opts){
    var prob, that, ref$, query, stat;
    opts == null && (opts = {});
    prob = yield model.findById(pid, 'config.round').populate('config.round', 'endTime').exec();
    if (!prob) {
      return;
    }
    if ((that = (ref$ = prob.config) != null ? ref$.round : void 8) != null) {
      if (!that.isEnded) {
        this.acquirePrivilege('rnd-all');
      }
    }
    log(prob);
    query = db.sol.model.aggregate({
      $match: {
        prob: pid
      }
    }, {
      $sort: {
        user: 1,
        "final.score": -1
      }
    }, {
      $group: {
        _id: {
          user: "$user"
        },
        score: {
          $first: "$final.score"
        }
      }
    });
    stat = yield query.exec();
    log(stat);
    return stat;
  },
  list: function*(opts){
    opts = import$(clone$(config.probListOpts), opts);
    return yield model.find({
      "config.round": {
        $exists: false
      }
    }, 'outlook.title stat').skip(opts.skip).limit(opts.limit).exec();
  },
  modify: function*(pid, prob){
    this.acquirePrivilege('prob-all');
    return yield model.update({
      _id: pid
    }, {
      $set: prob
    }, {
      upsert: true,
      overwrite: true
    }).exec();
  },
  updData: function*(pid){
    var prob, pairs;
    this.acquirePrivilege('prob-all');
    prob = yield model.findById(pid, 'config.dataset').exec();
    pairs = yield core.genDataPairs(pid);
    log("prob:", prob, "pairs:", pairs);
    prob.config.dataset = _.map((function(it){
      return it.weight = 1, it;
    }), pairs);
    yield prob.save();
  },
  listDataset: function*(pid){
    var prob;
    this.acquirePrivilege('prob-all');
    prob = yield model.findById(pid, "config.dataset").lean().exec();
    return prob.config.dataset;
  },
  nextCount: function*(){
    this.acquirePrivilege('prob-all');
    return yield conn.nextCount(model, count);
  }
});
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}