// Generated by LiveScript 1.3.1
(function(){
  var mongoose, mongooseDeepPopulate, mongooseAutoIncrement, util, _, moment, bluebird, co, logger, ObjectID, conn, myModel, solModel, probModel, userModel, roundModel, sol, prob, user, rnd, out$ = typeof exports != 'undefined' && exports || this;
  mongoose = require('mongoose');
  mongooseDeepPopulate = require('mongoose-deep-populate');
  mongooseAutoIncrement = require('mongoose-auto-increment');
  util = require('util');
  _ = require('prelude-ls');
  moment = require('moment');
  bluebird = require('bluebird');
  co = require('co');
  logger = console;
  ObjectID = mongoose.Schema.Types.ObjectID;
  out$.conn = conn = mongoose.createConnection('mongodb://localhost/dollast');
  mongooseAutoIncrement.initialize(conn);
  mongoose.plugin(mongooseDeepPopulate);
  myModel = (function(){
    myModel.displayName = 'myModel';
    var prototype = myModel.prototype, constructor = myModel;
    prototype.nextCount = function*(){
      this.counter || (this.counter = 1);
      while (yield this.model.findById(this.counter, '_id').lean().exec()) {
        this.counter += 1;
        console.log("@counter");
      }
      return this.counter;
    };
    function myModel(){
      this.nextCount = bind$(this, 'nextCount', prototype);
    }
    return myModel;
  }());
  solModel = (function(superclass){
    var prototype = extend$((import$(solModel, superclass).displayName = 'solModel', solModel), superclass).prototype, constructor = solModel;
    function solModel(){
      this.show = bind$(this, 'show', prototype);
      this.list = bind$(this, 'list', prototype);
      this.submit = bind$(this, 'submit', prototype);
      this.schema = new mongoose.Schema({
        code: String,
        time: Number,
        space: Number,
        lang: String,
        result: Number,
        prob: {
          type: Number,
          ref: "problem"
        },
        user: {
          type: String,
          ref: "user"
        },
        round: {
          type: Number,
          ref: "round"
        }
      });
      this.schema.plugin(mongooseAutoIncrement.plugin, {
        model: "solution"
      });
      this.model = conn.model('solution', this.schema);
    }
    prototype.submit = function*(req, uid){
      var res, sol;
      console.log(util.inspect(req) + "");
      res = runner.run(req.lang, req.code);
      sol = new this.model({
        code: req.code,
        time: res.time,
        space: res.space,
        lang: req.lang,
        prob: req.pid,
        user: uid,
        result: res.result
      });
      yield sol.save();
    };
    prototype.list = function*(){
      return yield this.model.find({}, '-code').populate('prob', 'outlook.title').lean().exec();
    };
    prototype.show = function*(sid){
      return yield this.model.findById(sid).populate('prob', 'outlook.title').lean().exec();
    };
    return solModel;
  }(myModel));
  probModel = (function(superclass){
    var prototype = extend$((import$(probModel, superclass).displayName = 'probModel', probModel), superclass).prototype, constructor = probModel;
    function probModel(){
      this.dataAtomSchema = new mongoose.Schema({
        input: String,
        output: String,
        weight: Number
      });
      this.schema = new mongoose.Schema({
        _id: Number,
        outlook: {
          desc: String,
          title: String,
          inFmt: String,
          outFmt: String,
          sampleIn: String,
          sampleOut: String
        },
        config: {
          round: {
            type: Number,
            ref: "round"
          },
          timeLmt: Number,
          spaceLmt: Number,
          regexp: String,
          dataset: [this.dataAtomSchema],
          disabled: Boolean
        },
        stat: {}
      });
      this.model = conn.model('problem', this.schema);
    }
    prototype.show = function*(pid, opts){
      var fields;
      opts == null && (opts = {});
      opts.mode || (opts.mode = "view");
      fields = (function(){
        switch (opts.mode) {
        case "view":
          return "outlook config.timeLmt config.spaceLmt";
        case "total":
          return undefined;
        default:
          throw Error('unimplemented');
        }
      }());
      return yield this.model.findById(pid, fields).exec();
    };
    prototype.list = function*(){
      return yield this.model.find({}, 'outlook.title stat').exec();
    };
    prototype.modify = function*(pid, prob){
      return yield this.model.update({
        _id: pid
      }, {
        $set: prob
      }, {
        upsert: true,
        overwrite: true
      }).exec();
    };
    return probModel;
  }(myModel));
  userModel = (function(){
    userModel.displayName = 'userModel';
    var prototype = userModel.prototype, constructor = userModel;
    function userModel(){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$.query = bind$(this$, 'query', prototype);
      this$.model = conn.model('user', {
        _id: String,
        pswd: String
      });
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.query = function(uid, pswd, salt, done){
      return this.model.findById(uid, function(err, user){
        if (err) {
          return done(err);
        } else if (!user || user.pswd !== pswd) {
          console.log('No such user');
          return done(null, false);
        } else {
          console.log('authenticate OK');
          return done(null, user);
        }
      });
    };
    return userModel;
  }());
  roundModel = (function(superclass){
    var prototype = extend$((import$(roundModel, superclass).displayName = 'roundModel', roundModel), superclass).prototype, constructor = roundModel;
    function roundModel(){
      var this$ = this instanceof ctor$ ? this : new ctor$;
      this$['delete'] = bind$(this$, 'delete', prototype);
      this$.list = bind$(this$, 'list', prototype);
      this$.show = bind$(this$, 'show', prototype);
      this$.modify = bind$(this$, 'modify', prototype);
      this$.schema = new mongoose.Schema({
        _id: Number,
        title: String,
        begTime: Date,
        endTime: Date,
        probs: [{
          type: Number,
          ref: "problem"
        }]
      });
      this$.model = conn.model('round', this$.schema);
      return this$;
    } function ctor$(){} ctor$.prototype = prototype;
    prototype.modify = function*(rid, rnd){
      var that;
      if (that = rnd.begTime) {
        rnd.begTime = new Date(that);
      }
      if (that = rnd.endTime) {
        rnd.endTime = new Date(that);
      }
      return yield this.model.update({
        _id: rid
      }, {
        $set: rnd
      }, {
        upsert: true,
        overwrite: true
      }).lean().exec();
    };
    prototype.show = function*(rid, opts){
      var rnd, started;
      opts == null && (opts = {});
      opts.mode || (opts.mode = "view");
      rnd = yield this.model.findById(rid).populate('probs', '_id outlook.title').lean().exec();
      if (opts.mode === "view" && moment().isBefore(rnd.begTime)) {
        rnd.probs = [];
        started = false;
      } else {
        started = true;
      }
      return {
        rnd: rnd,
        started: started
      };
    };
    prototype.list = function*(){
      return yield this.model.find({}, '_id title').lean().exec();
    };
    prototype['delete'] = function*(rid){
      return yield this.model.findByIdAndRemove(rid).lean().exec();
    };
    return roundModel;
  }(myModel));
  out$.sol = sol = new solModel;
  out$.prob = prob = new probModel;
  out$.user = user = new userModel;
  out$.rnd = rnd = new roundModel;
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
