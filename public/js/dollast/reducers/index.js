// Generated by LiveScript 1.3.1
(function(){
  var combineReducers, handleActions, I, auth, A, log, initState, loadFromTokenReducer, defaultThrow, useDefaultThrow, rootReducer, out$ = typeof exports != 'undefined' && exports || this;
  combineReducers = require('redux').combineReducers;
  handleActions = require('redux-actions').handleActions;
  I = require('immutable');
  auth = require('../utils/auth');
  A = require('../actions');
  log = debug('dollast:reducers');
  out$.initState = initState = I.fromJS({
    session: {
      guest: true
    }
  });
  loadFromTokenReducer = function(state, action){
    var token, payload, clientInfo;
    token = action.payload;
    payload = auth.jwt.dec(token);
    localStorage.token = token;
    clientInfo = JSON.parse(payload.client);
    return state.set('session', I.fromJS({
      guest: false,
      token: token,
      uid: clientInfo.uid
    }));
  };
  defaultThrow = function(state, action){
    log('error found:', action.payload.message, 'with', {
      state: state,
      action: action
    });
    return state;
  };
  useDefaultThrow = function(next){
    return {
      next: next,
      'throw': defaultThrow
    };
  };
  out$.rootReducer = rootReducer = handleActions({
    'load-from-token': loadFromTokenReducer,
    'register': useDefaultThrow(function(state, action){
      log('register', {
        action: action
      });
      return state;
    }),
    'login': useDefaultThrow(function(state, action){
      log({
        state: state,
        action: action
      });
      if (action.error) {
        return state;
      } else {
        return loadFromTokenReducer(state, {
          payload: action.payload.token
        });
      }
    }),
    'error': useDefaultThrow(function(state, action){
      return state;
    }),
    'logout': useDefaultThrow(function(state, action){
      return state.set('session', I.fromJS({
        guest: true
      }));
    }),
    'problem/refresh-list': useDefaultThrow(function(state, action){
      return state.setIn(['problem', 'list'], I.fromJS(action.payload));
    }),
    'problem/get': useDefaultThrow(function(state, action){
      return state.setIn(['problem', action.payload.load], I.fromJS(action.payload));
    }),
    'problem/update': useDefaultThrow(function(state, action){
      return state.setIn(['problem', 'update'], I.fromJS(action.payload));
    }),
    'solution/list': useDefaultThrow(function(state, action){
      return state.setIn(['solution', 'list'], I.fromJS(action.payload));
    }),
    'solution/get': useDefaultThrow(function(state, action){
      return state.setIn(['solution', 'show'], I.fromJS(action.payload));
    }),
    'round/get': useDefaultThrow(function(state, action){
      return state.setIn(['round', action.payload.load], I.fromJS(action.payload));
    }),
    'round/add-prob': useDefaultThrow(function(state, action){
      return state.updateIn(['round', 'update', 'probs'], function(probs){
        probs == null && (probs = I.List());
        return probs.push(action.payload);
      });
    }),
    'round/list': useDefaultThrow(function(state, action){
      return state.setIn(['round', 'list'], I.fromJS(action.payload));
    }),
    'round/show': useDefaultThrow(function(state, action){
      return state.setIn(['round', 'show'], I.fromJS(action.payload));
    })
  }, initState);
}).call(this);
