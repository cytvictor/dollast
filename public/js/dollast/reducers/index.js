// Generated by LiveScript 1.4.0
(function(){
  var combineReducers, handleActions, fromJS, auth, A, log, initState, loadFromTokenReducer, defaultThrow, useDefaultThrow, reducer, rootReducer, out$ = typeof exports != 'undefined' && exports || this;
  combineReducers = require('redux').combineReducers;
  handleActions = require('redux-actions').handleActions;
  fromJS = require('immutable').fromJS;
  auth = require('../utils/auth');
  A = require('../actions');
  log = debug('dollast:reducers');
  out$.initState = initState = fromJS({
    session: {
      guest: true
    }
  });
  loadFromTokenReducer = function(state, action){
    var token, payload, clientInfo;
    token = action.payload;
    payload = auth.jwt.dec(token);
    localStorage.token = token;
    clientInfo = JSON.parse(payload.client);
    return state.set('session', fromJS({
      guest: false,
      token: token,
      uid: clientInfo.uid
    }));
  };
  defaultThrow = function(state, action){
    log('error found:', action.payload.message, 'with', {
      state: state,
      action: action
    });
    return state;
  };
  useDefaultThrow = function(next){
    return {
      next: next,
      'throw': defaultThrow
    };
  };
  reducer = handleActions({
    'load-from-token': loadFromTokenReducer,
    'register': useDefaultThrow(function(state, action){
      log('register', {
        action: action
      });
      return state;
    }),
    'login': useDefaultThrow(function(state, action){
      log({
        state: state,
        action: action
      });
      if (action.error) {
        return state;
      } else {
        return loadFromTokenReducer(state, {
          payload: action.payload.token
        });
      }
    }),
    'error': useDefaultThrow(function(state, action){
      return state;
    }),
    'logout': useDefaultThrow(function(state, action){
      state.set('session', fromJS({
        guest: true
      }));
      return state.setIn(['db', 'site', 'login', 'post', 'status'], 'init');
    }),
    'problem/update': useDefaultThrow(function(state, action){
      return state.setIn(['problem', 'update'], fromJS(action.payload));
    }),
    'round/add-prob': useDefaultThrow(function(state, action){
      return state.updateIn(['round', 'update', 'probs'], function(probs){
        probs == null && (probs = fromJS([]));
        return probs.push(action.payload);
      });
    }),
    'problem/repair': useDefaultThrow(function(state, action){
      return state.setIn(['problem', 'update', 'config', 'dataset'], fromJS(action.payload.payload));
    }),
    'fetch': useDefaultThrow(function(state, action){
      var ref$, endpoint, body, path;
      ref$ = action.payload, endpoint = ref$.endpoint, body = ref$.body;
      endpoint = "db" + endpoint + "/get";
      path = endpoint.split('/');
      body.status = 'done';
      return state.setIn(path, fromJS(body));
    }),
    'send': useDefaultThrow(function(state, action){
      var ref$, endpoint, body, path;
      ref$ = action.payload, endpoint = ref$.endpoint, body = ref$.body;
      endpoint = "db" + endpoint + "/post";
      path = endpoint.split('/');
      body.status = 'done';
      return state.setIn(path, fromJS(body));
    }),
    'ui': useDefaultThrow(function(state, action){
      var ref$, endpoint, data, path;
      ref$ = action.payload, endpoint = ref$.endpoint, data = ref$.data;
      endpoint = "ui" + endpoint;
      path = endpoint.split('/');
      return state.setIn(path, fromJS(data));
    }),
    'loading': useDefaultThrow(function(state, action){
      var endpoint, path;
      endpoint = "db" + action.payload + "/status";
      path = endpoint.split('/');
      return state.setIn(path, 'wait');
    })
  }, initState);
  out$.rootReducer = rootReducer = reducer;
}).call(this);
